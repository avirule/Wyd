// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

static const int xprime = 1619;
static const int yprime = 31337;
static const int zprime = 6971;
static const int wprime = 1013;

static const float3 grad_3d[16] =
{
    float3(1, 1, 0),
    float3(-1, 1, 0),
    float3(1, -1, 0),
    float3(-1, -1, 0),
    float3(1, 0, 1),
    float3(-1, 0, 1),
    float3(1, 0, -1),
    float3(-1, 0, -1),
    float3(0, 1, 1),
    float3(0, -1, 1),
    float3(0, 1, -1),
    float3(0, -1, -1),
    float3(1, 1, 0),
    float3(0, -1, 1),
    float3(-1, 1, 0),
    float3(0, -1, -1)
};

float gradCoord3d(int seed, int3 xyz, float3 xyz0)
{
    int hash = seed;
    hash ^= (xprime * xyz.x);
    hash ^= (yprime * xyz.y);
    hash ^= (zprime * xyz.z);
    
    hash = hash * hash * hash * 60493;
    hash = (hash >> 13) ^ hash;
    
    float3 xyzg = grad_3d[hash & 15];
    
    return (xyz0.x * xyzg.x) + (xyz0.y * xyzg.y) + (xyz0.z * xyzg.z);
}

int fastFloor(float f)
{
    if (f >= 0)
    {
        return (int)f;
    } else {
        return (int)f - 1;
    }
}

float inverseLerp(float a, float b, float value)
{
    return clamp((value - a) / (b - a), 0.0, 1.0);
}

static const float F3 = 1.0 / 3.0;
static const float G3 = 1.0 / 6.0;
static const float G33 = ((1 / 6.0) * 3.0) - 1.0;

float singleSimplex(uint seed, float frequency, float3 xyz)
{
    xyz *= frequency;
    float t = (xyz.x + xyz.y + xyz.z) * F3;    
    float3 ijk = float3(fastFloor(xyz.x + t), fastFloor(xyz.y + t), fastFloor(xyz.z + t));
    
    t = (ijk.x + ijk.y + ijk.z) * G3;
    float3 xyz0 = float3(xyz.x - (ijk.x - t), xyz.y - (ijk.y - t), xyz.z - (ijk.z - t));
    float3 ijk1;
    float3 ijk2;
    
    if (xyz0.x >= xyz0.y)
    {
        if (xyz0.y >= xyz0.z)
        {
            ijk1 = float3(1.0, 0.0, 0.0);
            ijk2 = float3(1.0, 1.0, 0.0);
        }
        else if (xyz0.x >= xyz0.z)
        {
            ijk1 = float3(1.0, 0.0, 0.0);
            ijk2 = float3(1.0, 0.0, 1.0);
        }
        else
        {
            ijk1 = float3(0.0, 0.0, 1.0);
            ijk2 = float3(1.0, 0.0, 1.0);
        }
    }
    else
    {
        if (xyz0.y < xyz0.z)
        {
            ijk1 = float3(0.0, 0.0, 1.0);
            ijk2 = float3(0.0, 1.0, 1.0);
        }
        else if (xyz0.x < xyz0.z)
        {
            ijk1 = float3(0.0, 1.0, 0.0);
            ijk2 = float3(0.0, 1.0, 1.0);
        }
        else
        {
            ijk1 = float3(0.0, 1.0, 0.0);
            ijk2 = float3(1.0, 1.0, 0.0);
        }
    }
    
    float3 xyz1 = (xyz0 - ijk1) + G3;
    float3 xyz2 = (xyz0 - ijk2) + F3;
    float3 xyz3 = xyz0 + G33;
    float4 n;
    
    t = 0.6 - pow(xyz0.x, 2) - pow(xyz0.y, 2) - pow(xyz0.z, 2);
    
    if (t < 0.0)
    {
        n.x = 0.0;
    }
    else
    {
        t *= t;
        n.x = pow(t, 2) * gradCoord3d(seed, ijk, xyz0);
    }
    
    t = 0.6 - pow(xyz1.x, 2) - pow(xyz1.y, 2) - pow(xyz1.z, 2);
    if (t < 0.0)
    {
        n.y = 0.0;
    }
    else
    {
        t *= t;
        n.y = pow(t, 2) * gradCoord3d(seed, ijk + ijk1, xyz1);
    }
    
    t = 0.6 - pow(xyz2.x, 2) - pow(xyz2.y, 2) - pow(xyz2.z, 2);
    if (t < 0.0)
    {
        n.z = 0.0;
    }
    else
    {
        t *= t;
        n.z = pow(t, 2) * gradCoord3d(seed, ijk + ijk2, xyz2);
    }
    
    t = 0.6 - pow(xyz3.x, 2) - pow(xyz3.y, 2) - pow(xyz3.z, 2);
    if (t < 0.0)
    {
        n.w = 0.0;
    }
    else
    {
        t *= t;
        n.w = pow(t, 2) * gradCoord3d(seed, ijk + 1.0, xyz3);
    }
    
    return 32.0 * (n.x + n.y + n.z + n.w);
}


uniform uint _NoiseSeed;
uniform float3 _MaximumSize;
RWStructuredBuffer<float> Result;
float _Frequency;
float _Peristence;
float3 _Offset;

float customSimplexNoise(float3 xyz)
{
    float noise = singleSimplex(_NoiseSeed, _Frequency, xyz);
    noise += 5.0 * (1.0 - inverseLerp(0.0, _MaximumSize.y, xyz.y));
    noise /= (xyz.y + (-1.0 * _Peristence));
    return noise;
}

int coordTo1D(float3 coord)
{
    return (coord.x + (coord.z * _MaximumSize.x) + (coord.y * (_MaximumSize.x * _MaximumSize.z)));
}

float3 coordTo3D(uint index)
{
    uint y = index / (_MaximumSize.x * _MaximumSize.z);
    index -= (y * _MaximumSize.x * _MaximumSize.z);
    uint z = index / _MaximumSize.x;
    uint x = index % _MaximumSize.x;
    
    return float3(x, y, z);
}

[numthreads(256, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float3 coord = coordTo3D(id.x) + _Offset;
    float noise = customSimplexNoise(coord);

    Result[id.x] = noise;
}
