// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

static const int xprime = 1619;
static const int yprime = 31337;

static const float F2 = 1.0 / 2.0;
static const float G2 = 1.0 / 4.0;

static const float2 _grad_2D[8] =
{
    float2(-1, -1),
    float2(1, -1),
    float2(-1, 1),
    float2(1, 1),
    float2(0, -1),
    float2(-1, 0),
    float2(0, 1),
    float2(1, 0)
};

int fastFloor(float f)
{
    if (f >= 0)
    {
        return (int)f;
    } else {
        return (int)f - 1;
    }
}

float inverseLerp(float a, float b, float value)
{
    return clamp((value - a) / (b - a), 0.0, 1.0);
}

float gradCoord2D(int seed, float2 xy, float2 xy0)
{
    int2 xyi = (int2)xy;

    int hash = seed;
    hash ^= (xprime * xyi.x);
    hash ^= (yprime * xyi.y);

    hash = hash * hash * hash * 60493;
    hash = (hash >> 13) ^ hash;

    float2 xyg = _grad_2D[hash & 7];

    return (xy0.x * xyg.x) + (xy0.y * xyg.y);
}

float simplex2D(int seed, float frequency, float2 xy)
{
    xy *= frequency;

    float t = (xy.x + xy.y) * F2;
    float2 ij = float2(fastFloor(xy.x + t), fastFloor(xy.y + t));

    t = (ij.x + ij.y) * G2;
    float2 xy0 = float2(xy.x - (ij.x - t), xy.y - (ij.y - t));
    float2 ij1;

    if (xy0.x > xy0.y)
    {
        ij1 = float2(1.0, 0.0);
    }
    else
    {
        ij1 = float2(0.0, 1.0);
    }

    float2 xy1 = (xy0 - ij1) + G2;
    float2 xy2 = (xy0 - 1.0) + F2;
    float3 n;

    t = 0.5 - pow(xy0.x, 2) - pow(xy0.y, 2);
    if (t < 0.0)
    {
        n.x = 0.0;
    }
    else
    {
        t *= t;
        n.x = pow(t, 2) * gradCoord2D(seed, ij, xy0);
    }

    t = 0.5 - pow(xy1.x, 2) - pow(xy1.y, 2);
    if (t < 0.0)
    {
        n.y = 0.0;
    }
    else
    {
        t *= t;
        n.y = pow(t, 2) * gradCoord2D(seed, ij + ij1, xy1);
    }

    t = 0.5 - pow(xy2.x, 2) - pow(xy2.y, 2);
    if (t < 0.0)
    {
        n.z = 0.0;
    }
    else
    {
        t *= t;
        n.z = pow(t, 2) * gradCoord2D(seed, ij + 1, xy2);
    }

    return 50.0 * (n.x + n.y + n.z);
}


uniform uint _NoiseSeed;
uniform float _WorldHeight;
uniform float3 _MaximumSize;

float3 _Offset;
float _Frequency;
float _Persistence;

RWStructuredBuffer<float> Result;

int coordTo1D(int2 coord)
{
    return coord.x + (coord.y * _MaximumSize.x);
}

float2 coordTo2D(uint index)
{
    int y = index / _MaximumSize.x;
    int x = index % _MaximumSize.x;

    return float2(x, y);
}

float customSimplexNoise(float2 coord) {
    float noise = simplex2D(_NoiseSeed, _Frequency, coord);
    float noiseAsWorldHeight = inverseLerp(-1.0, 1.0, noise) * _WorldHeight;
    float noisePersistedWorldHeight = noiseAsWorldHeight + (((_WorldHeight / 2.0) - (noiseAsWorldHeight * 1.25)) * _Persistence);
    float noiseAsWorldHeightClamped = clamp(fastFloor(noisePersistedWorldHeight - _Offset.y), -_MaximumSize.y, _MaximumSize.y - 1);

    return noiseAsWorldHeightClamped;
}

[numthreads(1024, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float2 coord = _Offset.xz + coordTo2D(id.x);
    float noise = customSimplexNoise(coord);

    Result[id.x] = noise;
}
